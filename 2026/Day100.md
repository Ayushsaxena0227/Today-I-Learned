Part 1: PostgreSQL - The "Swiss Army Knife" of Databases
You asked: "When to choose PostgreSQL and when NOT to?"

A. When to Choose PostgreSQL (The Default Choice)
Answer: Almost always. Unless you have a specific reason not to.

Relational Data: Users have Orders, Orders have Products. Strict relationships.
ACID Compliance: You handle Money, Inventory, or critical business logic.
Complex Queries: You need to join 5 tables, filter by date range, and calculate the sum of sales in one go. SQL is king here.
JSON Needs: You want SQL structure but also need to store flexible data (like a "Settings" object). Postgres has a JSONB column type which is faster than MongoDB for many use cases.
B. When NOT to Choose PostgreSQL? (The Exceptions)
Massive Write Throughput: If you are building a Logging System (like Splunk) or IoT sensor data where you write 100,000 records per second. NoSQL (Cassandra/MongoDB) is better optimized for write-heavy loads.
Unstructured/Changing Data: If every row has completely different fields (e.g., a Content Management System where one page has 'Title' and another has 'Video URL' and 'Gallery'). MongoDB's schema-less nature wins here.
Simple Real-time Apps: For a basic chat app or live scoreboard, Firebase is faster to setup.
Part 2: PostgreSQL Fundamentals (The Core)

1. Tables & Columns (Schema)
   Unlike MongoDB, you MUST define the structure first.

Table: Like a spreadsheet (e.g., Users).
Column: A specific field (e.g., email). It has a Data Type.
VARCHAR(255): String with max length.
TEXT: Unlimited string.
INT: Integer number.
BOOLEAN: True/False.
TIMESTAMP: Date & Time. 2. Primary Key (PK) & Foreign Key (FK)
Primary Key: The unique ID of a row (e.g., user_id: 1). Every table needs one.
Foreign Key: The link to another table.
Order table has a column user_id. This user_id MUST exist in the User table. If you try to create an order for user_id: 999 (which doesn't exist), Postgres will throw an error. This is Data Integrity. 3. Constraints (Rules)
You can enforce rules at the database level.

NOT NULL: This field cannot be empty.
UNIQUE: No two users can have the same email.
CHECK (age > 18): The database will reject if age is 17.
Hinglish:
"Postgres mein sabse pehle Schema banana padta hai. Table define karo: 'Name text hoga, Age number hoga'.
Sabse important hai Constraints. Hum database ko bol sakte hain: 'Email unique hona chahiye' ya 'Age 18 se kam nahi honi chahiye'. Agar galti se code se galat data aaya, toh database khud mana kar dega. Ye safety MongoDB mein code likh ke karni padti hai."

Part 3: Intermediate PostgreSQL (The Power Moves)

1. Joins (Combining Data)
   In MongoDB, you do 2 queries (Get User -> Get Orders).
   In SQL, you do 1 query using JOIN.

INNER JOIN: Get records that have a match in both tables (Users WITH Orders).
LEFT JOIN: Get all Users, and their Orders if they have any (Users WITHOUT Orders too). 2. Transactions (All or Nothing)
This is crucial for payments.

Scenario: Transfer $100 from A to B.
Code:
SQL

BEGIN; -- Start Transaction
UPDATE accounts SET balance = balance - 100 WHERE id = 'A';
UPDATE accounts SET balance = balance + 100 WHERE id = 'B';
COMMIT; -- Save Everything
-- If error occurs before COMMIT, run ROLLBACK (Undo everything). 3. Indexing (Speed)
Without Index: Postgres reads every row to find email='john@test.com'. (Full Table Scan - Slow).
With Index: Postgres goes directly to the row. (B-Tree Search - Fast).
Command: CREATE INDEX idx_email ON users(email);
Part 4: Advanced Concepts (System Design Level)

1. Connection Pooling (pgBouncer)
   Problem: Node.js is fast. It opens 1000 connections to Postgres. Postgres creates a new process (heavy) for each connection. Server crashes (Out of Memory).
   Solution: Use a Connection Pooler (like pgBouncer or Prisma's built-in pool). It keeps 10 connections open and reuses them for 1000 requests.

2. JSONB (The NoSQL Killer)
   Scenario: You want to store user settings ({ theme: 'dark', notif: true }).
   Old SQL: Create a Settings table with columns theme, notif. Hard to change.
   Postgres JSONB: Create a column settings of type JSONB.

Query: SELECT \* FROM users WHERE settings->>'theme' = 'dark';
Indexing: You can even index specific keys inside the JSON!
Summary Checklist for Interview
Recruiter: "Tell me about your PostgreSQL experience."

You:
"I use PostgreSQL as my primary database because of its robust ACID compliance and relational capabilities.

Schema Design: I define strict schemas with Primary and Foreign Keys to ensure data integrity (e.g., an Order cannot exist without a valid User).
Performance: I use Indexes on frequently searched columns (like email/status) and optimize queries using JOINS instead of multiple round-trips.
Advanced Features: For flexible data like user preferences, I leverage the JSONB column type, which gives me NoSQL-like flexibility within a SQL environment.
Transactions: I wrap critical operations (like payments) in BEGIN...COMMIT blocks to ensure data consistency."
